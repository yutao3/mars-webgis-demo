<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>SAIIL Mars Web GIS Prototype</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="icon" href="favicon.ico" />
  <!-- OpenLayers (no SRI to avoid integrity/CORS pitfalls) -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ol@9.2.4/ol.css">
  <script src="https://cdn.jsdelivr.net/npm/ol@9.2.4/dist/ol.js"></script>
  <style>
    html, body { margin:0; height:100%; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;}
    #map { width:100%; height:100%; position:relative; background:#0a0a14; } /* deep space vibe */
    /* Controls panel */
    .panel {
      position:absolute; top:10px; left:10px; z-index:1000;
      background:rgba(20,20,28,0.9); color:#e6e6ea; border:1px solid #2a2a3a;
      border-radius:12px; padding:10px 12px; backdrop-filter: blur(4px); min-width: 260px;
      box-shadow: 0 6px 18px rgba(0,0,0,0.35);
    }
    .panel h3 { margin:6px 0 8px; font-size:14px; font-weight:600; letter-spacing:0.2px; }
    .group { margin-bottom:10px; }
    .group label { display:block; margin:6px 0; cursor:pointer; }
    .row { display:flex; gap:6px; flex-wrap:wrap; }
    .row button, .row select {
      appearance:none; border:1px solid #3a3a4a; background:#171722; color:#e6e6ea; border-radius:10px;
      padding:7px 10px; cursor:pointer; font-size:13px;
    }
    .row button:hover { border-color:#6b6bff; }
    .row button.active { border-color:#9f9fff; box-shadow: 0 0 0 2px rgba(120,120,255,0.25) inset; }
    .small { font-size:12px; opacity:0.9; }
    .error {
      position:absolute; top:10px; right:10px; z-index:1000;
      background:#2b1111; color:#ffd7d7; border:1px solid #723; padding:10px 12px; border-radius:10px;
      max-width:420px; display:none;
    }
    /* Bottom-right overlay: scalebar + logo */
    .br-wrap {
      position:absolute; right:10px; bottom:10px; z-index:1000; display:flex; flex-direction:column; align-items:flex-end; gap:8px;
    }
    /* We'll draw our OWN scale bar on export, but on-map we use OL's ScaleLine styled to sit bottom-right */
    .ol-scale-line {
      position:static; /* keep inside .br-wrap stack */
      background:rgba(20,20,28,0.9); color:#e6e6ea; border:1px solid #2a2a3a; border-radius:8px; padding:2px 6px;
    }
    .logo {
      width:160px; height:auto; opacity:0.95; border-radius:10px; border:1px solid #2a2a3a; background:#0f0f16;
      padding:6px;
    }
    /* Measure tooltip */
    .tooltip {
      position: absolute; background: rgba(20,20,28,0.9); color: #fff; padding: 4px 8px;
      border: 1px solid #2a2a3a; border-radius: 6px; white-space: nowrap; pointer-events: none;
      transform: translate(-50%, -120%);
      font-size:12px;
    }
    .tooltip.hidden { display:none; }

    /* Simple credits */
    .credits {
      position:absolute; right:10px; top:10px; z-index:1000; font-size:11px; color:#bbb;
      background:rgba(0,0,0,0.35); padding:4px 6px; border-radius:8px;
    }
  </style>
</head>
<body>
  <div id="map"></div>

  <div class="panel" id="ui">
    <div class="group">
      <h3>Layers</h3>
      <label><input type="checkbox" id="chk-mola" checked> MOLA 463 m (default)</label>
      <label><input type="checkbox" id="chk-hmc"> HMC_11W24_ND5 (CTX/HiRISE composite)</label>
      <div class="small">The map auto-zooms to MOLA on load.</div>
    </div>

    <div class="group">
      <h3>Annotations & Measure</h3>
      <div class="row">
        <button id="btn-select" title="Select/Move features">Select</button>
        <button id="btn-point" title="Add points">Point</button>
        <button id="btn-line" title="Add line (measure length)">Line</button>
        <button id="btn-poly" title="Add polygon (measure area)">Polygon</button>
        <button id="btn-clear" title="Clear all annotations">Clear</button>
      </div>
      <div class="small">Distances/areas computed on a Mars sphere (R≈3,396,190 m).</div>
    </div>

    <div class="group">
      <h3>Print</h3>
      <div class="row">
        <button id="btn-export">Export PNG</button>
      </div>
      <div class="small">Exports layers, annotations, and a drawn scale bar.</div>
    </div>
  </div>

  <div class="credits">© SAIIL – Mars Web GIS Prototype</div>

  <div class="error" id="err"></div>

  <!-- Bottom-right stack: ScaleLine + Logo -->
  <div class="br-wrap">
    <div id="scaleSlot"></div>
    <img class="logo" src="SAIIL-logo-medium-size.png" alt="SAIIL logo" onerror="this.style.display='none'">
  </div>

  <script>
    // Aliases (OpenLayers UMD bundle)
    const Map = ol.Map;
    const View = ol.View;
    const TileLayer = ol.layer.Tile;
    const ImageLayer = ol.layer.Image;
    const VectorLayer = ol.layer.Vector;
    const GeoTIFF = ol.source.GeoTIFF;
    const VectorSource = ol.source.Vector;
    const ImageStatic = ol.source.ImageStatic;
    const OSM = ol.source.OSM;
    const {fromLonLat, addProjection, addCoordinateTransforms, Projection} = ol.proj;
    const {ScaleLine, defaults: defaultControls} = ol.control;
    const {Draw, Modify, Select, defaults: defaultInteractions} = ol.interaction;
    const {Style, Stroke, Fill, Circle: CircleStyle} = ol.style;
    const {LineString, Polygon} = ol.geom;
    const Overlay = ol.Overlay;
    const {getArea, getLength} = ol.sphere;

    // === Mars spherical model ===
    // Mars_GCS_2000 is geographic lon/lat on a Mars sphere (no EPSG). We'll define a custom 'MARS:4326'.
    const MARS_RADIUS = 3396190; // meters (mean radius)
    const marsProj = new Projection({
      code: 'MARS:4326',
      units: 'degrees',
      extent: [-180, -90, 180, 90],
      global: true,
      worldExtent: [-180, -90, 180, 90]
    });
    ol.proj.addProjection(marsProj);

    // Utility: meters per pixel at current view center (horizontally), for Mars sphere in degrees
    function metersPerPixel(map) {
      const size = map.getSize();
      if (!size) return 0;
      const px = 1;
      const center = map.getView().getCenter();
      if (!center) return 0;
      const res = map.getView().getResolution(); // degrees per pixel
      if (!res) return 0;

      const lon = center[0], lat = center[1];
      const lon2 = lon + res * px;
      const c1 = [lon, lat];
      const c2 = [lon2, lat];
      return getLength(new LineString([c1, c2], 'XY'), {radius: MARS_RADIUS}) / px;
    }

    // === Annotation layer & styles ===
    const vectorSource = new VectorSource();
    const vectorLayer = new VectorLayer({
      source: vectorSource,
      style: feature => {
        const geom = feature.getGeometry();
        const baseStroke = new Stroke({ color: '#9f9fff', width: 2 });
        const fill = new Fill({ color: 'rgba(159,159,255,0.15)' });
        if (geom instanceof LineString) {
          return new Style({ stroke: baseStroke });
        } else if (geom instanceof Polygon) {
          return new Style({ stroke: baseStroke, fill });
        } else {
          return new Style({ image: new CircleStyle({ radius:5, fill: new Fill({color:'#9f9fff'}), stroke: new Stroke({color:'#333', width:1}) }) });
        }
      }
    });

    // === Basemap GeoTIFF layers ===
    const URL_MOLA = "https://archives.esac.esa.int/psa/ftp/Guest-Storage-Facility/UCL-MSSL_Oxia-Planum_HRSC_CTX_HiRISE_MADNet_V1.0/MOLA_463m_OXIA_CROP_HRSC-Proj.tif";
    const URL_HMC  = "https://archives.esac.esa.int/psa/ftp/Guest-Storage-Facility/UCL-MSSL_Oxia-Planum_HRSC_CTX_HiRISE_MADNet_V1.0/HMC_11W24_ND5_OXIA_CROP.tif";

    // Each as an Image layer backed by GeoTIFF source (geotiff.js inside OL). If CORS blocks, we catch and notify.
    function makeGeoTiffLayer(url, title) {
      const src = new GeoTIFF({
        sources: [{ url }],
        convertToRGB: true, // for 8-bit single-band, display as grayscale
        interpolate: true,
        // normalize false keeps original 8-bit range; let OL stretch; if needed set false:
        normalize: false
      });
      const layer = new ImageLayer({ source: src, visible: title.includes('MOLA') }); // MOLA on by default
      layer.set('title', title);
      return layer;
    }

    const molaLayer = makeGeoTiffLayer(URL_MOLA, 'MOLA 463m');
    const hmcLayer  = makeGeoTiffLayer(URL_HMC,  'HMC 11W24 ND5');

    // === Map & view ===
    const map = new Map({
      target: 'map',
      layers: [
        // Optional tiny dark base in case GeoTIFFs fail (commented; OL Image layers will render directly)
        // new TileLayer({ source: new OSM(), visible:false }),
        molaLayer,
        hmcLayer,
        vectorLayer
      ],
      view: new View({
        projection: marsProj,
        center: [0, 0], // degrees
        zoom: 2,        // temporary; we will fit to MOLA extent on load
        minZoom: 1,
        maxZoom: 22
      }),
      controls: defaultControls({ zoom: true, attribution: false })
    });

    // === Scale bar (on-map display) ===
    const scale = new ScaleLine({
      units: 'metric',
      minWidth: 140,
      bar: false,
      steps: 4
    });
    // Attach the ScaleLine DOM into our bottom-right stack (.br-wrap)
    scale.setTarget(document.getElementById('scaleSlot'));
    map.addControl(scale);

    // === Error surface ===
    const errBox = document.getElementById('err');
    function showError(msg) {
      errBox.textContent = msg;
      errBox.style.display = 'block';
      setTimeout(()=>{ errBox.style.display='none'; }, 9000);
    }

    // === Fit to MOLA when ready ===
    molaLayer.getSource().on('change', () => {
      const state = molaLayer.getSource().getState?.();
      if (state === 'ready' || state === 'loaded') {
        const extent = molaLayer.getSource().getImageExtent?.();
        if (extent) {
          map.getView().fit(extent, { padding:[20,20,20,20], duration: 600 });
        }
      } else if (state === 'error') {
        showError('Failed to load MOLA GeoTIFF (CORS or network). If this persists, host a CORS-enabled copy.');
      }
    });
    hmcLayer.getSource().on('change', () => {
      const state = hmcLayer.getSource().getState?.();
      if (state === 'error') {
        showError('Failed to load HMC GeoTIFF (CORS or network).');
      }
    });

    // === Layer toggles ===
    const chkMola = document.getElementById('chk-mola');
    const chkHmc  = document.getElementById('chk-hmc');
    chkMola.addEventListener('change', ()=> molaLayer.setVisible(chkMola.checked));
    chkHmc.addEventListener('change',  ()=> hmcLayer.setVisible(chkHmc.checked));

    // === Interactions: select / draw / modify ===
    const select = new Select();
    const modify = new Modify({ source: vectorSource });
    map.addInteraction(select);
    map.addInteraction(modify);

    let draw = null;
    function setMode(mode) {
      // remove existing draw
      if (draw) { map.removeInteraction(draw); draw = null; }
      // deactivate select while drawing, then re-enable
      if (mode === 'select') {
        select.setActive(true);
        modify.setActive(true);
        setActiveButton('btn-select');
        tooltip.classList.add('hidden');
        return;
      }
      select.setActive(false);
      modify.setActive(false);

      if (mode === 'point' || mode === 'line' || mode === 'poly') {
        const type = mode === 'point' ? 'Point' : (mode === 'line' ? 'LineString' : 'Polygon');
        draw = new Draw({ source: vectorSource, type });
        map.addInteraction(draw);
        setActiveButton(mode === 'point' ? 'btn-point' : mode === 'line' ? 'btn-line' : 'btn-poly');

        // Measurement feedback
        draw.on('drawstart', evt => {
          tooltip.classList.remove('hidden');
          updateTooltip(evt.feature);
          evt.feature.on('change', () => updateTooltip(evt.feature));
        });
        draw.on('drawend', () => {
          setTimeout(()=>tooltip.classList.add('hidden'), 200);
        });
      }
    }

    function setActiveButton(id) {
      ['btn-select','btn-point','btn-line','btn-poly'].forEach(b=>{
        const el = document.getElementById(b);
        if (!el) return;
        if (b === id) el.classList.add('active'); else el.classList.remove('active');
      });
    }

    document.getElementById('btn-select').onclick = ()=> setMode('select');
    document.getElementById('btn-point').onclick  = ()=> setMode('point');
    document.getElementById('btn-line').onclick   = ()=> setMode('line');
    document.getElementById('btn-poly').onclick   = ()=> setMode('poly');
    document.getElementById('btn-clear').onclick  = ()=> vectorSource.clear();

    // Start in Select mode
    setMode('select');

    // === Measure tooltip overlay ===
    const tooltip = document.createElement('div');
    tooltip.className = 'tooltip hidden';
    const tooltipOverlay = new Overlay({ element: tooltip, offset:[0, -12], positioning:'bottom-center' });
    map.addOverlay(tooltipOverlay);

    function formatLength(m) {
      if (m > 1000) return (m/1000).toFixed(2) + ' km';
      return m.toFixed(1) + ' m';
    }
    function formatArea(a) {
      if (a > 1e6) return (a/1e6).toFixed(2) + ' km²';
      return a.toFixed(1) + ' m²';
    }
    function updateTooltip(feature) {
      const geom = feature.getGeometry();
      let txt = '';
      if (geom instanceof LineString) {
        const coords = geom.getCoordinates();
        const len = getLength(new LineString(coords, 'XY'), {radius: MARS_RADIUS});
        txt = 'Length: ' + formatLength(len);
        tooltipOverlay.setPosition(coords[coords.length-1]);
      } else if (geom instanceof Polygon) {
        const coords = geom.getCoordinates()[0];
        const area = getArea(new Polygon([coords], 'XY'), {radius: MARS_RADIUS});
        txt = 'Area: ' + formatArea(area);
        // place near last vertex
        tooltipOverlay.setPosition(coords[coords.length-2] || coords[0]);
      } else {
        const c = geom.getCoordinates();
        tooltipOverlay.setPosition(c);
        txt = `Point: ${c.map(v=>v.toFixed(4)).join(', ')}`;
      }
      tooltip.textContent = txt;
    }

    // === Export PNG (layers + annotations + custom scale bar + logo) ===
    document.getElementById('btn-export').onclick = async () => {
      try {
        const size = map.getSize();
        if (!size) return;
        // Force a synchronous render
        map.renderSync();
        // Composite all layer canvases
        const exportCanvas = document.createElement('canvas');
        exportCanvas.width = size[0];
        exportCanvas.height = size[1];
        const ctx = exportCanvas.getContext('2d');

        // Draw each OL layer canvas in order
        document.querySelectorAll('.ol-layer canvas').forEach(layerCanvas => {
          if (layerCanvas.width > 0) {
            ctx.globalAlpha = layerCanvas.parentNode.style.opacity ? Number(layerCanvas.parentNode.style.opacity) : 1;
            const transform = layerCanvas.style.transform;
            // Parse matrix(a, b, c, d, e, f)
            const matrix = transform.match(/^matrix\(([^\(]+)\)$/);
            if (matrix) {
              const vals = matrix[1].split(',').map(Number);
              ctx.setTransform(vals[0], vals[1], vals[2], vals[3], vals[4], vals[5]);
            } else {
              ctx.setTransform(1, 0, 0, 1, 0, 0);
            }
            ctx.drawImage(layerCanvas, 0, 0);
          }
        });

        // Reset transform
        ctx.setTransform(1,0,0,1,0,0);

        // Draw a custom scale bar (bottom-right above the logo)
        drawExportScaleBar(ctx);

        // Draw logo if present in DOM
        const logoImg = document.querySelector('.logo');
        if (logoImg && logoImg.complete && logoImg.naturalWidth > 0) {
          const margin = 10;
          const w = Math.min(160, exportCanvas.width * 0.2);
          const aspect = logoImg.naturalHeight / logoImg.naturalWidth;
          const h = w * aspect;
          ctx.save();
          ctx.globalAlpha = 0.95;
          roundRect(ctx, exportCanvas.width - w - margin, exportCanvas.height - h - margin, w, h, 10);
          ctx.clip();
          ctx.drawImage(logoImg, exportCanvas.width - w - margin, exportCanvas.height - h - margin, w, h);
          ctx.restore();
          // thin border
          ctx.strokeStyle = 'rgba(255,255,255,0.25)';
          ctx.lineWidth = 1;
          roundRect(ctx, exportCanvas.width - w - margin, exportCanvas.height - h - margin, w, h, 10);
          ctx.stroke();
        }

        const dataURL = exportCanvas.toDataURL('image/png');
        // trigger download
        const a = document.createElement('a');
        a.href = dataURL;
        a.download = 'saiil-mars-map.png';
        a.click();
      } catch (e) {
        console.error(e);
        showError('Export failed (see console). Some browsers block cross-origin canvases.');
      }
    };

    function roundRect(ctx, x, y, w, h, r) {
      ctx.beginPath();
      ctx.moveTo(x + r, y);
      ctx.arcTo(x + w, y, x + w, y + h, r);
      ctx.arcTo(x + w, y + h, x, y + h, r);
      ctx.arcTo(x, y + h, x, y, r);
      ctx.arcTo(x, y, x + w, y, r);
      ctx.closePath();
    }

    function niceScale(max) {
      // nice round numbers: 1, 2, 5 × 10^n
      const pow = Math.pow(10, Math.floor(Math.log10(max)));
      const d = max / pow;
      if (d >= 5) return 5 * pow;
      if (d >= 2) return 2 * pow;
      return 1 * pow;
    }

    function drawExportScaleBar(ctx) {
      const pxPerM = 1 / Math.max(1e-9, metersPerPixel(map)); // pixels per meter
      // target a bar ~ 180px
      const targetPx = 180;
      const targetMeters = targetPx / Math.max(1e-9, pxPerM);
      const barMeters = niceScale(targetMeters);
      const barPx = barMeters * pxPerM;

      const margin = 14;
      const barH = 10;
      const x = ctx.canvas.width - barPx - margin;
      const y = ctx.canvas.height - margin - 8 - barH; // leave room for text and logo

      // background
      ctx.fillStyle = 'rgba(20,20,28,0.9)';
      ctx.strokeStyle = 'rgba(255,255,255,0.25)';
      ctx.lineWidth = 1;
      roundRect(ctx, x - 8, y - 10, barPx + 16, barH + 26, 8);
      ctx.fill();
      ctx.stroke();

      // bar
      ctx.fillStyle = '#e6e6ea';
      ctx.fillRect(x, y, barPx, barH);

      // label
      ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, Arial';
      ctx.fillStyle = '#e6e6ea';
      const label = barMeters >= 1000 ? (barMeters/1000).toFixed(barMeters%1000===0?0:1) + ' km'
                                      : Math.round(barMeters) + ' m';
      ctx.fillText(label, x, y - 4);
    }

    // Basic keyboard shortcuts
    document.addEventListener('keydown', (e)=>{
      if (e.key === 'Escape') setMode('select');
      if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'e') {
        e.preventDefault(); document.getElementById('btn-export').click();
      }
    });

    // If either GeoTIFF throws a network/CORS error early, catch via a quick HEAD check (best-effort)
    // (Some browsers won’t allow HEAD without CORS; this is just a gentle preflight to give feedback sooner.)
    ;(async function preflight(){
      for (const [u,name] of [[URL_MOLA,'MOLA'], [URL_HMC,'HMC']]) {
        try {
          const r = await fetch(u, { method:'HEAD', mode:'cors' });
          if (!r.ok) throw new Error(`${r.status} ${r.statusText}`);
        } catch (e) {
          showError(`${name} may be blocked by CORS on this origin. If loading fails, mirror it with CORS enabled or use a dev proxy.`);
        }
      }
    })();
  </script>
</body>
</html>
